<h3>Relevance of access on migrated / chained rows compared to total amount of table access</h3>
chained rows causes additional read of migrated rows in separate DB-blocks while accessing a record which is not completely contained in current block.<br/>
Chained rows can be avoided by adjusting PCTFREE and reorganization of affected table.<br/>
This selection shows the relevance of access on chained rows compared to total amount of table access.<pre style='background-color: #FFFFCC;'>WITH Inst_Filter AS (SELECT :P1 Instance FROM DUAL)
                      SELECT x.*, CASE WHEN "table fetch by rowid"+"table scan rows gotten" > 0 THEN
                                  ROUND("table fetch continued row" / ("table fetch by rowid"+"table scan rows gotten") * 100,2)
                                  ELSE 0 END "Pct. chained row access"
                      FROM   (
                              SELECT /*+ NO_MERGE*/ ROUND(Begin_Interval_Time, 'MI') Start_Time,
                                     SUM(CASE WHEN Stat_Name = 'table fetch continued row' THEN Value ELSE 0 END) "table fetch continued row",
                                     SUM(CASE WHEN Stat_Name = 'table fetch by rowid'      THEN Value ELSE 0 END) "table fetch by rowid",
                                     SUM(CASE WHEN Stat_Name = 'table scan rows gotten'    THEN Value ELSE 0 END) "table scan rows gotten"
                              FROM   (
                                      SELECT /*+ NO_MERGE*/ ss.Begin_Interval_Time, st.Stat_Id, st.Stat_Name, ss.Min_Snap_ID, st.Snap_ID,
                                             Value - LAG(Value, 1, Value) OVER (PARTITION BY st.Instance_Number, st.Stat_ID ORDER BY st.Snap_ID) Value
                                      FROM   (SELECT /*+ NO_MERGE*/ DBID, Instance_Number, Begin_Interval_Time, Snap_ID,
                                                     MIN(Snap_ID) OVER (PARTITION BY Instance_Number) Min_Snap_ID
                                              FROM   DBA_Hist_Snapshot ss
                                              WHERE  Begin_Interval_Time >= SYSDATE - :P2
                                              AND    ( (SELECT Instance FROM Inst_Filter) IS NULL OR ss.Instance_Number = (SELECT Instance FROM Inst_Filter)    )
                                             ) ss
                                      JOIN   DBA_Hist_SysStat st ON st.DBID=ss.DBID AND st.Instance_Number=ss.Instance_Number
                                      WHERE  st.Snap_ID = ss.Snap_ID /* Vorgänger des ersten mit auswerten für Differenz per LAG */
                                      AND    st.Stat_Name IN ('table fetch continued row', 'table fetch by rowid', 'table scan rows gotten')
                                    ) hist
                              WHERE  hist.Value >= 0    /* Ersten Snap nach Reboot ausblenden */
                              AND    hist.Snap_ID > hist.Min_Snap_ID /* Vorgaenger des ersten Snap fuer LAG wieder ausblenden */
                              GROUP BY ROUND(Begin_Interval_Time, 'MI')
                             ) x
                      ORDER BY 1
                      </pre><div>Parameter :P1: Optional filter for selection on RAC-instance</div><div>Parameter :P2: Number of days in history backward from now for consideration</div>