<h3>JDBC client statement cache probably not used (Evaluation of SGA)</h3>
The number of soft parses on JDBC thin connections suggests that client-side JDBC statement caching is not being used or the statement cache setting may be too low.<br/>
     JDBC client-side statement caching allows to keep a number of frequently used SQL cursors open at the DB connection even if the JDBC statment handle in the application is closed.<br/>
     This allows to improve application performance and reduce soft parse activity even if application itself is unable to keep frequently used cursors open.<br/>
     To be unable to keep frequently used cursors open is often the case if the application uses OR-mapper frameworks.<br/>
<br/>
     The JDBC statement cache is disabled per default in Oracle's JDBC driver.<br/>
     There are two ways to activate JDBC client-side statement caching and set cache size (to 100 for example):<br/>
<br/>
     1. Enable on JDBC connection:<br/>
     ((OracleConnection)conn).setImplicitCachingEnabled(true));<br/>
     ((OracleConnection)conn).setStatementCacheSize(100));<br/>
<br/>
     2. Enable via JDBC URL (starting with DB release 19c):<br/>
     jdbc:oracle:thin:@tcp://myorclhostname:1521/myorclservicename?oracle.jdbc.implicitStatementCacheSize=100<br/>
    <pre style='background-color: #FFFFCC;'>SELECT SUM(x.Parse_Calls)       Parse_Calls_Total,
       SUM(x.Executions)        Executions_Total,
       u.UserName, x.Max_ASH_Module, x.Max_ASH_Action, x.Max_ASH_Machine, sv.Name Max_ASH_Service_Name,
       SUM(x.Samples)           ASH_Samples,
       COUNT(DISTINCT SQL_ID)   Distinct_SQL_Statements,
       MAX(Max_Parses_SQL_ID)   Max_Parses_SQL_ID
FROM   (SELECT s.Inst_ID, s.SQL_ID, h.Samples, h.Max_ASH_User_ID, h.Max_ASH_Module, h.Max_ASH_Action, h.Max_ASH_Machine, h.Max_ASH_Service_Hash,
               s.Executions, s.Parse_Calls,
               MAX(s.SQL_ID)  OVER (PARTITION BY h.Max_ASH_User_ID, h.Max_ASH_Module, h.Max_ASH_Action, h.Max_ASH_Machine, h.Max_Ash_Service_Hash ORDER BY s.Parse_Calls DESC) Max_Parses_SQL_ID
        FROM   gv$SQLArea s
        JOIN   (SELECT Inst_ID, SQL_ID, SUM(Samples) Samples,
                        MAX(Max_ASH_User_ID)      Max_ASH_User_ID,
                        MAX(Max_ASH_Module)       Max_ASH_Module,
                        MAX(Max_ASH_Action)       Max_ASH_Action,
                        MAX(Max_ASH_Machine)      Max_ASH_Machine,
                        MAX(Max_ASH_Service_Hash) Max_ASH_Service_Hash
                FROM   (
                        SELECT /*+ NO_MERGE */ Inst_ID, SQL_ID, Module, Action, Machine, Service_Hash, COUNT(*) Samples,
                               MAX(User_ID)      OVER (PARTITION BY Inst_ID, SQL_ID ORDER BY COUNT(*) DESC) Max_ASH_User_ID,
                               MAX(Module)       OVER (PARTITION BY Inst_ID, SQL_ID ORDER BY COUNT(*) DESC) Max_ASH_Module,
                               MAX(Action)       OVER (PARTITION BY Inst_ID, SQL_ID ORDER BY COUNT(*) DESC) Max_ASH_Action,
                               MAX(Machine)      OVER (PARTITION BY Inst_ID, SQL_ID ORDER BY COUNT(*) DESC) Max_ASH_Machine,
                               MAX(Service_Hash) OVER (PARTITION BY Inst_ID, SQL_ID ORDER BY COUNT(*) DESC) Max_ASH_Service_Hash
                        FROM   gv$Active_Session_History h
                        WHERE  SQL_ID IS NOT NULL
                        AND    Program = 'JDBC Thin Client'
                        GROUP BY Inst_ID, SQL_ID, User_ID, Module, Action, Machine, Service_Hash
                       )
                GROUP BY Inst_ID, SQL_ID
               ) h ON h.Inst_ID = s.Inst_ID AND h.SQL_ID = s.SQL_ID
       ) x
JOIN   gv$Services sv ON sv.Inst_ID = x.Inst_ID AND sv.Name_Hash = x.Max_ASH_Service_Hash
JOIN   All_Users u    ON u.User_ID = x.Max_ASH_User_ID
GROUP BY u.UserName, x.Max_ASH_Module, x.Max_ASH_Action, x.Max_ASH_Machine, sv.Name
HAVING SUM(Parse_Calls) > SUM(Executions)/:P1
ORDER BY Parse_Calls_Total DESC
        </pre><div>Parameter :P1: Parse count in % compared to execution count</div>