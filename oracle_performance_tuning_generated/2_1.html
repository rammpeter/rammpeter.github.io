<h3>Identifikation von HotBlocks im DB-Cache: Suboptimale Indizes</h3>
Indizes mit hoher Datenfluktuation und Schieflage (z.B. fortlaufende Nummern) scannen nach Record-Löschungen sukzessive mehr DB-Blöcke beim Zugriff.<br/>
Problematisch ist insbesondere Zugriff auf erste Records solcher moving windows.<br/>
Evtl. notwendige Reorganisation kann z.B. per ALTER INDEX COALESCE erfolgen.<pre style='background-color: #FFFFCC;'>SELECT * FROM (
                      SELECT /*+ NO_MERGE MATERIALIZE */ p.Inst_ID "Inst", p.SQL_ID, p.Child_Number "Child Number", s.Executions "Executions",
                             s.Buffer_Gets "Buffer gets", s.Rows_Processed "Rows processed",
                             ROUND(s.Rows_Processed/s.Executions,2) "Rows per Exec.",
                             ROUND(s.Buffer_Gets/s.Rows_Processed)  "Buffer Gets per Row",
                             s.SQL_Text, s.SQL_FullText
                      FROM   (
                              SELECT p.Inst_ID, p.SQL_ID, p.Child_Number
                              FROM   gv$SQL_Plan p
                              WHERE  Operation NOT IN ('PARTITION HASH')
                              AND    Options NOT IN ('STOPKEY')  -- RowNum-Abgrenzung ausfiltern
                              GROUP BY p.Inst_ID, p.SQL_ID, p.Child_Number
                              HAVING
                              -- Ausfuehrungsplan hat genau einen Index-Zugriff ohne Filter
                                     SUM(CASE WHEN p.Operation = 'INDEX' AND p.Options in ('RANGE SCAN', 'UNIQUE SCAN')
                                         THEN 1 ELSE 0 END
                                        ) = 1
                              -- Keine Filter
                              AND    SUM(CASE WHEN P.FILTER_PREDICATES IS NOT NULL
                                         THEN 1 ELSE 0 END
                                        ) = 0
                            -- Keine Gruppenfunktionen
                              AND    SUM(CASE WHEN p.ID = 1 AND p.Options IN ('GROUP BY', 'AGGREGATE')
                                         THEN 1 ELSE 0 END
                                        ) = 0
                              AND    COUNT(*) < :P1
                             ) p
                      JOIN   gv$SQL s ON s.Inst_ID = p.Inst_ID AND s.SQL_ID = p.SQL_ID AND s.Child_Number = p.Child_Number
                      WHERE  s.Rows_Processed > 0 -- Nur dann sinnvolle Werte
                      AND    s.Executions     > :P2 -- Nur relevante Ausfuehrungen
                      AND    s.Rows_Processed > s.Executions/:P3 -- Nur dann sinnvolle Werte
                      )
                      WHERE LENGTH(REGEXP_REPLACE(SQL_Text, '[^:]','')) < :P4  -- Anzahl Bindevariablen < x
                      AND    "Buffer Gets per Row" > :P5                         -- nur problematische anzeigen
                      ORDER BY "Buffer Gets per Row" * "Rows processed" DESC NULLS LAST</pre><div>Parameter :P1: Maximale Anzahl Operationen im Execution Plan des SQL</div><div>Parameter :P2: Minimale Anzahl Executions für Aufnahme in Selektion</div><div>Parameter :P3: Maximale Anzahl Bindevariablen im Statement</div><div>Parameter :P4: Minimale Anzahl Rows processed / Execution</div><div>Parameter :P5: Minimale Anzahl Buffer gets per Row</div>