<h3>Possibly expensive TABLE ACCESS BY INDEX ROWID with additional filter predicates on table</h3>
If in a SQL a table has additional filter conditions that are not covered by the used index you may consider to extend the index by these filter conditions.<br/>
This would ensure that you do the more expensive TABLE ACCESS BY ROWID only if that table row matches all your access conditions checked by the index.<br/>
This selection considers current SGA<pre style='background-color: #FFFFCC;'>
              SELECT Table_Owner, Table_Name, Index_Name,
                     Elapsed_Secs               "Elapsed time SQL total (sec.)",
                     Ash_Seconds_Tab            "Table access time ASH (sec.)",
                     SQL_ID_Max_Elapsed_Secs    "SQL-ID with max. total elapsed",
                     SQL_ID_Max_Ash_Seconds_Tab "SQL-ID with max. ASH per table",
                     Index_Access               "Access criteria on index",
                     Table_Filter               "Filter criteria on table"
              FROM   (
                      SELECT Table_Owner, Table_Name, Index_Name,
                             SUM(Elapsed_Secs) Elapsed_Secs, SUM(Ash_Seconds_Tab) Ash_Seconds_Tab,
                             MAX(SQL_ID) KEEP (DENSE_RANK LAST ORDER BY Elapsed_Secs) SQL_ID_Max_Elapsed_Secs,
                             MAX(SQL_ID) KEEP (DENSE_RANK LAST ORDER BY Ash_Seconds_Tab) SQL_ID_Max_Ash_Seconds_Tab,
                             Index_Access, Table_Filter
                      FROM   (
                              SELECT ind.Inst_ID, ind.SQL_ID, ind.Plan_Hash_Value, ind.Child_Number, ind.ID Ind_ID, tab.ID tab_ID, tab.Table_Owner, tab.Table_Name, ind.Index_Name,
                                     ROUND(s.Elapsed_Time/1000000) Elapsed_Secs, ash.ash_Seconds_Tab,
                                     ind.Access_Predicates Index_Access, tab.Filter_Predicates Table_Filter
                              FROM   (
                                      SELECT /*+ NO_MERGE */  Inst_ID, SQL_ID, Plan_Hash_Value, Child_Number, ID, Object_Owner Index_Owner, Object_Name Index_Name, Access_Predicates
                                      FROM   gv$SQL_Plan
                                      WHERE  Access_Predicates IS NOT NULL
                                      AND    Operation LIKE 'INDEX%'
                                      AND    Object_Owner NOT IN ('SYS')
                                     ) ind
                              JOIN   DBA_Indexes i ON i.Owner = ind.Index_Owner AND i.Index_Name = ind.Index_Name
                              JOIN   (
                                      SELECT /*+ NO_MERGE */ Inst_ID, SQL_ID, Plan_Hash_Value, Child_Number, ID, Object_Owner Table_Owner, Object_Name Table_Name, Filter_Predicates
                                      FROM   gv$SQL_Plan
                                      WHERE  Filter_Predicates IS NOT NULL
                                      AND    Operation LIKE 'TABLE ACCESS%'
                                      AND    Options LIKE 'BY INDEX ROWID%'
                                      AND    Object_Owner NOT IN ('SYS')
                                     ) tab ON tab.Inst_ID = ind.Inst_ID AND tab.SQL_ID = ind.SQL_ID AND tab.Plan_Hash_Value = ind.Plan_Hash_Value AND tab.Child_Number = ind.Child_Number AND
                                              tab.Table_Owner = i.Table_Owner AND tab.Table_Name = i.Table_Name AND tab.ID < ind.ID -- Index kommt unter table beim index-Zugriff
                              JOIN   (SELECT /*+ NO_MERGE */ Inst_ID, SQL_ID, Plan_Hash_Value, Child_Number, Elapsed_Time
                                      FROM   gv$SQL
                                      WHERE  Elapsed_Time > :P1 * 1000000
                                     )s ON S.INST_ID = ind.Inst_ID AND s.SQL_ID = ind.SQL_ID AND s.Plan_Hash_Value = ind.Plan_Hash_Value AND s.Child_Number = ind.Child_Number
                              LEFT OUTER JOIN ( -- Ash may be removed after short time but SQL remains in SGA
                                      SELECT /*+ NO_MERGE */ inst_ID, SQL_ID, SQL_Plan_Hash_Value, SQL_Child_Number, SQL_Plan_Line_ID, COUNT(*) Ash_Seconds_Tab
                                      FROM   gv$Active_Session_History
                                      WHERE  SQL_Plan_Hash_Value != 0 -- kein SQL
                                      GROUP BY inst_ID, SQL_ID, SQL_Plan_Hash_Value, SQL_Child_Number, SQL_Plan_Line_ID
                                     ) ash ON ash.INST_ID = ind.Inst_ID AND ash.SQL_ID = ind.SQL_ID AND ash.SQL_Plan_Hash_Value = ind.Plan_Hash_Value AND ash.SQL_Child_Number = ind.Child_Number AND ash.SQL_Plan_Line_ID = tab.ID
                             )
                      GROUP BY Table_Owner, Table_Name, Index_Name, Index_Access, Table_Filter
                     )
              WHERE  Elapsed_Secs >= :P2
              AND    NVL(Ash_Seconds_Tab, :P3) >= 0
              ORDER BY Elapsed_Secs + NVL(Ash_Seconds_Tab, 0) DESC
            </pre><div>Parameter :P1: Minimum amount of elapsed seconds an SQL must have in GV$SQL to be considered in this selection</div><div>Parameter :P2: Minimum amount of elapsed seconds of all SQLs in SGA that are accessing the considered table to be shown in this selection</div><div>Parameter :P3: Minimum amount of elapsed seconds in GV$Active_Session_History of for TABLE ACCESS BY ROWID on the considered table to be shown in this selection. Value=0 means: show this table access also if there are no records in active session history for this access.</div>