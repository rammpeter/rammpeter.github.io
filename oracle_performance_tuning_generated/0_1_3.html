<h3>Detection of unused indexes by MONITORING USAGE</h3>
DB monitors usage (access) on indexes if declared so before by 'ALTER INDEX ... MONITORING USAGE'.<br/>
Results of usage monitoring can be queried from v$Object_Usage but only for current schema.<br/>
Over all schemas usage can be monitored with following SQL.<br/>
Caution:<br/>
- Recursive index-lookup by foreign key validation does not count as usage in v$Object_Usage.<br/>
- So please be careful if index is only needed for foreign key protection (to prevent full scans on detail-table at deletes on master-table).<br/>
- GATHER_TABLE_STATS and GATHER_INDEX_STATS may also counts as usage even if no other select touches this index (no longer detected in DB-version >= 12).<br/>
<br/>
Additional information about index usage can be requested from DBA_Hist_Seg_Stat and DBA_Hist_Active_Sess_History.<pre style='background-color: #FFFFCC;'>
                    WITH Constraints AS (SELECT /*+ NO_MERGE MATERIALIZE */ Owner, Constraint_Name, Constraint_Type, Table_Name, R_Owner, R_Constraint_Name FROM DBA_Constraints)
                    SELECT /*+ USE_HASH(i ic cc c rc rt) */ u.*, ROUND(NVL(u."End monitoring", SYSDATE)-u."Start monitoring", 1) "Days without usage",
                           i.Num_Rows, i.Distinct_Keys,
                           seg.MBytes,
                           i.Tablespace_Name "Tablespace", i.Uniqueness, i.Index_Type,
                           (SELECT IOT_Type FROM DBA_Tables t WHERE t.Owner = u.Owner AND t.Table_Name = u.Table_Name) "IOT Type",
                           c.Constraint_Name                                                          "Foreign key protection",
                           CASE WHEN rc.Table_Name IS NOT NULL THEN rc.Owner||'.'||rc.Table_Name END  "Referenced table",
                           rt.Num_Rows                                                                "Num rows of referenced table",
                           ic.Column_Name                                                             "Column name"
                    FROM   (
                            SELECT /*+ NO_MERGE */ u.UserName Owner, io.name Index_Name, t.name Table_Name,
                                   decode(bitand(i.flags, 65536), 0, 'NO', 'YES') Monitoring,
                                   decode(bitand(ou.flags, 1), 0, 'NO', 'YES') Used,
                                   TO_DATE(ou.Start_Monitoring, 'MM/DD/YYYY HH24:MI:SS') "Start monitoring",
                                   TO_DATE(ou.End_Monitoring, 'MM/DD/YYYY HH24:MI:SS')   "End monitoring"
                            FROM   sys.object_usage ou
                            JOIN   sys.ind$ i  ON i.obj# = ou.obj#
                            JOIN   sys.obj$ io ON io.obj# = ou.obj#
                            JOIN   sys.obj$ t  ON t.obj# = i.bo#
                            JOIN   DBA_Users u ON u.User_ID = io.owner#  --
                            CROSS JOIN (SELECT UPPER(:P1) Name FROM DUAL) schema
                            WHERE  TO_DATE(ou.Start_Monitoring, 'MM/DD/YYYY HH24:MI:SS') < SYSDATE-:P2
                            AND    (schema.name IS NULL OR schema.Name = u.UserName)
                           )u
                    JOIN DBA_Indexes i                    ON i.Owner = u.Owner AND i.Index_Name = u.Index_Name AND i.Table_Name=u.Table_Name
                    LEFT OUTER JOIN DBA_Ind_Columns ic    ON ic.Index_Owner = u.Owner AND ic.Index_Name = u.Index_Name AND ic.Column_Position = 1
                    LEFT OUTER JOIN DBA_Cons_Columns cc   ON cc.Owner = ic.Table_Owner AND cc.Table_Name = ic.Table_Name AND cc.Column_Name = ic.Column_Name AND cc.Position = 1
                    LEFT OUTER JOIN Constraints c     ON c.Owner = cc.Owner AND c.Constraint_Name = cc.Constraint_Name AND c.Constraint_Type = 'R'
                    LEFT OUTER JOIN Constraints rc    ON rc.Owner = c.R_Owner AND rc.Constraint_Name = c.R_Constraint_Name
                    LEFT OUTER JOIN DBA_Tables rt         ON rt.Owner = rc.Owner AND rt.Table_Name = rc.Table_Name
                    JOIN (SELECT /*+ NO_MERGE */ Owner, Segment_Name, ROUND(SUM(bytes)/(1024*1024),1) MBytes
                          FROM   DBA_Segments
                          GROUP BY Owner, Segment_Name
                          HAVING SUM(bytes)/(1024*1024) > :P3
                         ) seg ON seg.Owner = u.Owner AND seg.Segment_Name = u.Index_Name
                    WHERE u.Used='NO' AND u.Monitoring='YES'
                    ORDER BY seg.MBytes DESC NULLS LAST
                   </pre><div>Parameter :P1: List only indexes for this schema (optional)</div><div>Parameter :P2: Minumin age in days of Start-Monitoring timestamp of unused index</div><div>Parameter :P3: Minumin size of index in MB to be considered in selection</div>