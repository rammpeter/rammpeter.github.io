<h3>Estimate network latency between client and database by evaluation of Active Session History</h3>
The network latency between client and database server can be estimated by the number of number of SQL executions of one session between two ASH snapshots.<br/>
If an application executes the same very short running SQL against the DB over and over again in a loop, then:<br/>
- it is a bad architecture approach for the application because the network latency will cause a significant overhead for application performance<br/>
- however, this behavior gives a possibility for a weak estimation of the network latency between client and database server<br/>
Assuming that the processing time in the application between two DB calls is very short compared to the network latency and DB execution time,<br/>
then a time delay can be estimated by the time between two SQL executions minus the average SQL execution time at the DB.<br/>
This time delay can be treated as the time for the network latency for a round trip plus the client side execution preparation (like JDBC stack, value binding etc.).<br/>
This client side execution preparation should be constant and quite small compared to the network latency, so we may assume the named values mostly as network latency.<br/>
<pre style='background-color: #FFFFCC;'>
SELECT x.Inst_ID, u.UserName, x.Session_ID, x.Session_Serial# Serial_No, x.SQL_ID, x.Machine, x.Module, x.Action,
       x.Consecutive_ASH_Samples, x.Min_Sample_Time, x.Max_Sample_Time,
       x.Executions,
       ROUND(s.Elapsed_ms_per_Exec, 3) Avg_SQL_Elapsed_ms_per_Exec,
       ROUND(x.Consecutive_ASH_Samples*1000.0 / x.Executions, 3) Avg_ms_between_two_executions,
       /* The time between two executions - the avg. SQL execution time of this SQL */
       ROUND(x.Consecutive_ASH_Samples*1000.0 / x.Executions -  s.Elapsed_ms_per_Exec, 3) Avg_Network_and_App_Latency_ms
FROM   (
        SELECT Inst_ID, Session_ID, Session_Serial#, User_ID,  SQL_ID, Machine, MIN(Module) Module, MIN(Action) Action,
               COUNT(*) Consecutive_ASH_Samples,
               MIN(Sample_Time) Min_Sample_Time,
               MAX(Sample_Time) Max_Sample_Time,
               MAX(SQL_Exec_ID) - MIN(SQL_Exec_ID) Executions
        FROM   (SELECT x.*,
                       Sample_ID - ROW_NUMBER() OVER (PARTITION BY Inst_ID, Session_ID, Session_Serial#  ORDER BY Sample_ID) AS grp /* Same group as long as no gaps are in sample_id */

                FROM   (
                        SELECT Sample_ID, Sample_Time, Inst_ID, User_ID, Session_ID, Session_Serial#, SQL_ID, SQL_Exec_ID, Machine, Module, Action,
                               LAG(SQL_ID,        1, 0) OVER (PARTITION BY Inst_ID, Session_ID, Session_Serial# ORDER BY Sample_Time) Prev_SQL_ID,
                               LAG(SQL_Exec_ID,   1, 0) OVER (PARTITION BY Inst_ID, Session_ID, Session_Serial# ORDER BY Sample_Time) Prev_SQL_Exec_ID,
                               LAG(Sample_ID,     1, 0) OVER (PARTITION BY Inst_ID, Session_ID, Session_Serial# ORDER BY Sample_Time) Prev_Sample_ID,
                               LEAD(Sample_ID,    1, 0) OVER (PARTITION BY Inst_ID, Session_ID, Session_Serial# ORDER BY Sample_Time) Next_Sample_ID
                        FROM   gv$Active_Session_History
                        WHERE  SQL_ID IS NOT NULL
                        AND    PLSQL_Entry_Object_ID IS NULL  /* Exclude local executions without network influence */
                        AND    PLSQL_Object_ID IS NULL        /* Exclude local executions without network influence */
                       ) x
                WHERE  SQL_ID = Prev_SQL_ID                   /* The same SQL is executed consecutive, the same SQL_ID is needed as precondition to count the executions by SQL_Exec_ID */
                AND    SQL_Exec_ID > Prev_SQL_Exec_ID         /* Each snapshot sees a new SQL execution and SQL_Exec_ID was increasing */
                AND    (Sample_ID = Prev_Sample_ID + 1 OR     /* No gap between the snapshots of this session */
                        Sample_ID = Next_Sample_ID - 1 )
               )
        GROUP BY Inst_ID, Session_ID, Session_Serial#, User_ID,  SQL_ID, Machine, grp
        HAVING COUNT(*) > :P1 /* minimum result count to get valid statistic results */
       ) x
JOIN   (SELECT Inst_ID, SQL_ID, Elapsed_Time/1000.0 / DECODE(Executions, 0, 1, Executions) Elapsed_ms_per_Exec
        FROM   gv$SQLArea
       ) s ON s.Inst_ID = x.Inst_ID AND s.SQL_ID = x.SQL_ID
JOIN   All_Users u ON u.User_ID = x.User_ID
WHERE  s.Elapsed_ms_per_Exec < :P2
ORDER BY Machine, Consecutive_ASH_Samples DESC
           </pre><div>Parameter :P1: The minimum number of consecutive ASH records with the same SQL_ID for a session to allow valid statistic considerations</div><div>Parameter :P2: Maximum milliseconds per execution for the considered SQL to ensure that there are enough executions within on ASH cycle for plausible statistics</div>